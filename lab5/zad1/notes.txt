W czytujemy linijki z pliku
Dla kazdej linijki tworzymy tyle procesow ile jest komend. 
Procesy kolejnych komend z linii sa polaczone potokami (plynie w prawo) i przekazuja swoje wyjscie na wejscie kolejnej komendy.
Interpreter (main) czeka az wszystko sie wykona i wypisujemy wynik (chyba xd)
Potem kolejna linijka.

#define _XOPEN_SOURCE 500
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <signal.h>
#define MAX_ARGUMENTS 2
#define MAX_COMBINED 3

int main(int argc, char** args){
    if(argc != 2)
        error("Wrong number of arguments");

    FILE* file = fopen(args[1],"r");
    if(file == NULL)
        error("cannot open fiel");

    ssize_t read;
    char* line;
    size_t len = 0;

    pid_t workers[MAX_COMBINED];
    int worker_count = 0;

    int** fds = calloc(MAX_COMBINED, sizeof(int*));
    for(int i=0; i<MAX_COMBINED; i++){
        fds[i] = calloc(2,sizeof(int));
        pipe(fds[i]);
    }

    char** commands = calloc(MAX_ARGUMENTS + 1,sizeof(char*));

    while((read = getline(&line, &len, file) != -1)){
        char* token = strtok(line,"|");
        int pipe_num = 0;
        while(token != NULL){
            int i = 0; //number of arguments in a single |...|
            while((commands[i] = strtok(token, " ")) != NULL && i <= MAX_ARGUMENTS + 1){
                i++;
                if((workers[worker_count] = fork()) == 0){
                    char* arg[i]; //wszystkie argumenty bez komendy
                    for(int j =1; j<i-1; j++)
                        arg[j] = commands[j];
                    arg[i-1] = NULL; //null na koncu

                    close(fds[pipe_num][0]);


                    if(dup2(fds[pipe_num][1],STDOUT_FILENO) != STDOUT_FILENO)
                        error("dup2 error to stdout");
                    
                    if(pipe_num > 0 && dup2(fds[pipe_num-1][1],STDIN_FILENO) != STDIN_FILENO){
                            error("dup2 error to stdoin");
                    }

                    execv(commands[0], arg);
                }
            }
            pipe_num++;
        }
    }



    return 0;
}